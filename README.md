# ТЕМА 11. Итераторы и генераторы
Отчет по Теме #11 выполнил:
- Чемезов Михаил Владимирович
- АИС-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + |   |
| Задание 4 | + |   |
| Задание 5 | + |   |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
- Простой итератор, но у него нет гибкой настройки, например его нельзя развернуть. Он работает просто как next(), но нет prev()
### Код
- Без декоратора
```python
numbers = [0, 1, 2, 3, 4, 5]
for item in numbers:
    print(item)
```

### Результат
- Без декоратора
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab1_1.png)
- С декоратором
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab1_2.png)
### Вывод:
- Создается список numbers и заполняется значениями [0, 1, 2, 3, 4, 5].
- Запускается цикл for, который будет последовательно проходить по каждому элементу списка.
- Переменная item получает значение первого элемента списка (в данном случае 0).
- Выполняется команда print(item), которая выводит значение item (в данном случае 0).
- Цикл повторяется для каждого элемента списка, пока не закончится список.
- Код печатает каждый элемент списка numbers по очереди.

## Лабораторная работа №2
- Класс итератор с гибкой настройкой и удобными применением
### Код
```python
class CountDown:
    def __init__(self, start):
        self.count = start + 1

    def __iter__(self):
        return self

    def __next__(self):
        self.count -= 1
        if self.count < 0:
            raise StopIteration
        return self.count


if __name__ == '__main__':
    counter = CountDown(5)
    for i in counter:
        print(i)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab2.png)
### Вывод:
- Определяется класс CountDown.
- Внутри класса определяется метод __init__, который принимает аргумент start. В этом методе устанавливается атрибут count равным start + 1.
- Затем определяется метод __iter__, который возвращает self, что позволяет экземпляру класса быть итерируемым.
- Далее определяется метод __next__. В этом методе count уменьшается на 1 и затем проверяется условие: если count стал меньше 0, то генерируется исключение StopIteration. Иначе возвращается значение count.
- Создается экземпляр класса CountDown с аргументом 5 и сохраняется в переменной counter.
- Далее запускается цикл for, который проходит по каждому элементу в counter.
- В теле цикла выводится каждое значение i.
- Код будет напечатать значение i на каждой итерации цикла, начиная с 5 и заканчивая 0.

## Лабораторная работа №3
- Генератор списка
### Код
```python
a = [i ** 2 for i in range(1, 5)]

print('a -', a)
for i in a:
    print(i)

print('iter(a) - ', iter(a))
for i in a:
    print(i)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab3.png)
### Выводы:
- Создается переменная a, в которую записывается результат выражения [i ** 2 for i in range(1, 5)]. Это выражение использует генератор списка для создания списка квадратов чисел от 1 до 4. Таким образом, в a будет сохранен список [1, 4, 9, 16].
- Выводится строка "a -" с последующим выводом значения переменной a. В результате будет выведено: "a - [1, 4, 9, 16]".
- Запускается цикл for для каждого элемента i в списке a.
- На первой итерации будет выведено значение 1. На второй итерации будет выведено значение 4. На третьей итерации будет выведено значение 9. На четвертой итерации будет выведено значение 16.
- Выводится строка "iter(a) - " с последующим выводом результата вызова функции iter(a). Эта функция возвращает итератор для a.
- Запускается еще один цикл for для каждого элемента i в списке a. В данном случае, переменная a сама по себе является итерируемым объектом, поэтому Python автоматически использует встроенную функцию iter(), чтобы получить итератор для нее.
- На первой итерации будет выведено значение 1. На второй итерации будет выведено значение 4. На третьей итерации будет выведено значение 9. На четвертой итерации будет выведено значение 16.
- Код выведет два списка значений из переменной a, а затем еще два списка значений из переменной a, пройденных через итератор.
  
## Лабораторная работа №4
- Выражения генераторы
### Код
```python
b = (i ** 2 for i in range(1, 5))
print(b) #вывод не такой как у генератора списков
print('first')
for i in b:
    print(i)
print('second')
# из-за особенностей выражений генераторов, они не будут выводиться больше одного раза
for i in b:
    print(i)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab4.png)
### Выводы:
- Создается переменная b, в которую записывается результат выражения (i ** 2 for i in range(1, 5)). Это выражение использует генератор списка для создания генератора объектов с квадратами чисел от 1 до 4.
- Выводится переменная b. Поскольку b - это генератор, вывод его напрямую не отобразит элементы генератора, а лишь выведет информацию о самом объекте-генераторе.
- Выводится строка "first".
- Запускается цикл for для каждого элемента i в генераторе b. В этом цикле будут выводиться значения, сгенерированные генератором на этом этапе.
- На первой итерации будет выведено значение 1. На второй итерации будет выведено значение 4. На третьей итерации будет выведено значение 9. На четвертой итерации будет выведено значение 16.
- Выводится строка "second". Однако здесь ничего не будет выведено, так как генератор b уже исчерпан в предыдущем цикле for. Второй цикл for не произведет вывод ни одного значения.
- Код выведет содержимое генератора b только в первом цикле for. Второй цикл for не выведет никакого значения, так как генератор уже был исчерпан в первом цикле.

## Лабораторная работа №5
- Такой же счетчик, как и в первом задании, только это генератор и использует yield
### Код
```python
def countdown(count):
    while count >= 0:
        yield count
        count -= 1


if __name__ == '__main__':
    counter = countdown(5)
    for i in counter:
        print(i)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab5.png)
### Выводы:
- Объявляется функция countdown, которая принимает аргумент count.
- Внутри функции запускается бесконечный цикл while, который продолжается до тех пор, пока count больше или равен 0.
- Внутри цикла используется ключевое слово yield для генерации значений. Каждый раз, когда цикл проходит через оператор yield, он возвращает текущее значение count и затем приостанавливает выполнение функции.
- В блоке if __name__ == '__main__': находятся инструкции, которые выполняются только, если файл запускается напрямую, а не импортируется.
- Создается переменная counter, в которую сохраняется результат вызова функции countdown(5). Это создает экземпляр генератора, который будет производить значения от 5 до 0.
- Затем запускается цикл for, который проходит через все значения, производимые генератором counter.
- На каждой итерации значения, полученные из генератора, сохраняются в переменную i, и далее выводятся с помощью функции print().
- После запуска кода, на каждой итерации цикла будет выводиться значение, возвращаемое генератором countdown, начиная с 5 и заканчивая 0.
- Код выведет последовательность чисел от 5 до 0.

## Самостоятельная работа №1
- Вас никак не могут оставить числа Фибоначчи, очень уж они вас 
заинтересовали. Изучив новые возможности Python вы решили 
реализовать программу, которая считает числа Фибоначчи при 
помощи итераторов. Расчет начинается с чисел 1 и 1. Создайте 
функцию fib(n), генерирующую n чисел Фибоначчи с 
минимальными затратами ресурсов. Для реализации этой функции потребуется обратиться к инструкции yield (Она не сохраняет в 
оперативной памяти огромную последовательность, а дает 
возможность “доставать” промежуточные результаты по одному).
Результатом решения задачи будет листинг кода и вывод в консоль с числом Фибоначчи от 200.
### Код
```python
def fib(n):
    a, b = 1, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

fib_sequence = fib(200)
for i in fib_sequence:
    print(i)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Sam1_1.png)
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Sam1_2.png)
### Выводы:
- Объявляется функция fib(n), которая принимает аргумент n - количество чисел в последовательности Фибоначчи, которые нужно сгенерировать.
- Внутри функции создаются две переменные a и b, которые инициализируются значением 1. Они представляют первые два числа последовательности Фибоначчи.
- Затем используется цикл for для итерации от 0 до n-1 (т.е. range(n)). Внутри цикла происходит следующее:
- С помощью ключевого слова yield функция возвращает значение a на каждой итерации, что позволяет генерировать следующее число последовательности и при этом сохранять состояние функции между итерациями.
- После этого значения переменных a и b обновляются, генерируя следующее число последовательности Фибоначчи.
- Создается переменная fib_sequence, в которую сохраняется результат вызова функции fib(200). Это создает экземпляр генератора для генерации последовательности Фибоначчи из 200 чисел.
- В последнем цикле for значение каждого числа из генератора fib_sequence выводится на экран с помощью функции print.
- Этот код генерирует и выводит первые 200 чисел последовательности Фибоначчи.

## Самостоятельная работа №2
- К коду предыдущей задачи добавьте запоминание каждого числа Фибоначчи в файл “fib.txt”, при этом каждое число должно 
находиться на отдельной строчке. Результатом выполнения задачи будет листинг кода и скриншот получившегося файла
### Код
```python
def fib(n):
    a, b = 1, 1
    with open("fib.txt", "w") as file:
        for _ in range(n):
            file.write(str(a) + "\n")
            a, b = b, a + b
            yield a

fib_sequence = fib(200)
for i in fib_sequence:
    print(i)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Sam2.png)
### Выводы:
- Создается функция fib(n), которая принимает аргумент n - количество чисел в последовательности Фибоначчи, которые нужно сгенерировать.
- Внутри функции открывается файл "fib.txt" в режиме записи с помощью оператора with open("fib.txt", "w") as file:. Это позволяет открыть файл "fib.txt" для записи и автоматически закрыть его после завершения блока кода.
- Затем используется цикл for для итерации от 0 до n-1 (т.е. range(n)). Внутри цикла происходит следующее:
- Значение переменной a записывается в файл "fib.txt" с помощью метода write(). После каждого числа добавляется символ новой строки \n.
- После записи значения, переменные a и b обновляются, генерируя следующее число последовательности Фибоначчи.
- С помощью ключевого слова yield возвращается новое значение a на каждой итерации, что позволяет генерировать следующее число последовательности и при этом сохранять состояние функции между итерациями.
- Создается переменная fib_sequence, в которую сохраняется результат вызова функции fib(200). Это создает экземпляр генератора для генерации последовательности Фибоначчи из 200 чисел.
- В последнем цикле for каждое значение из генератора fib_sequence выводится на экран с помощью функции print.
- Этот код генерирует последовательность Фибоначчи из 200 чисел, записывая каждое число в файл "fib.txt" и выводя их на экран.

## Общие выводы по теме
- Итераторы и генераторы представляют собой инструменты для работы с последовательностями данных.
- Итератор - это объект, который предоставляет последовательный доступ к элементам коллекции или последовательности. Он обеспечивает метод __iter__ для инициализации итератора и метод __next__ для получения следующего элемента.
- Генератор - это вид итератора, который позволяет удобно создавать итерируемые объекты с минимумом усилий. Генераторы могут быть созданы с использованием функций, которые используют ключевое слово yield.
- Основное различие между итераторами и генераторами заключается в том, что генераторы могут быть созданы с использованием функций, в то время как итераторы обычно создаются с помощью классов.
- Генераторы обеспечивают "ленивую" загрузку данных, что позволяет эффективно обрабатывать большие объемы данных.
- Использование генераторов позволяет экономить память и ресурсы процессора, так как следующий элемент вычисляется только при запросе.
- Генераторы могут быть бесконечными, в то время как итераторы имеют определенное количество элементов.
- Генераторы и итераторы широко используются в Python для обработки файлов, больших данных, итерации по ресурсам с ограниченным доступом и т. д.
