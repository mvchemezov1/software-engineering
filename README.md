# Тема 9.  Концепции и принципы ООП
Отчет по Теме #9 выполнил:
- Чемезов Михаил Владимирович
- АИС-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
-  Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте  класс,  указав  в  свойствах  только  имя.  Дальше  создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав  атрибут,  который  не  указан  в  вашем  классе,  например, попробуйте вызвать фамилию.
### Код
```python
class Michael:
    __slots__ = ['name']

    def __init__(self, name):
        if name == 'Михаил':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Да, я {name}"

person1 = Michael('Алексей')
person2 = Michael('Михаил')
print(person1.name)
print(person2.name)

person2.surname = 'Чемезов'
print(person2.surname)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Lab1.png)
### Вывод:
- Код создает класс "Car" с двумя атрибутами: "make" (марка) и "model" (модель) автомобиля.
- Конструктор класса "init" принимает два параметра "make" и "model"
- Инициализируются соответствующие атрибуты объекта класса Car.
- Далее, создается экземпляр класса "my_car" с аргументами "Lada" (марка) и "Granta" (модель)
- Таким образом, переменная "my_car" будет ссылаться на объект класса "Car" с атрибутами make="Lada" и model="Granta".

## Лабораторная работа №2
- Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте  метод,  выводящий  на  печать  «Мороженое  с {ТОППИНГ}»  в  случае  наличия  добавки,  а  иначе  отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.
### Код
```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print('Обычное мороженое')


icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадное')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Lab2.png)
### Вывод:
- Создается объект "my_car" класса "Car" с аргументами "Lada" и "Granta".
- Форматируется строка, чтобы значения атрибутов "self.make" и "self.model" подставились в нужные места.
- Код выводит на экран строку, состоящую из значения атрибута "self.make", значения атрибута "self.model" и текста "Driving the";
- Вызывается метод "drive()" у этого объекта, в результате чего выводится на экран "Driving the Lada Granta".

## Лабораторная работа №3
- Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.
Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.
### Код
```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):     #установка значения атрибута
        self._value = value

    def get_value(self):    #получение значения атрибута
        return self._value

    def del_value(self):    #удаление атрибута
        del self._value

    value = property(get_value, set_value, del_value, 'Свойство value')

obj = MyClass(42)
print(obj.get_value())
obj = MyClass(45)
print(obj.get_value())
obj = MyClass(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Lab3.png)
### Выводы:
- Класс Car имеет конструктор __init__, который принимает make и model в качестве параметров и инициализирует соответствующие переменные экземпляра.
- Класс Car имеет метод drive, который выводит сообщение о том, что машина в движении.
- подкласс ElectricCar класса Car имеет свой собственный __init__, который расширяет __init__ класса Car с помощью super().
- подкласс ElectricCar принимает дополнительный параметр battery_capacity и инициализирует новую переменную экземпляра.
- подкласс ElectricCar имеет метод charge, который выводит сообщение о том, что электромобиль заряжается.
- Создаются экземпляры классов (my_car и my_electric_car), и вызываются их методы drive и charge.
- Выводятся сообщения: driving the Lada Granta, driving the Nissan Ariya и charging the Nissan Ariya with 78 kWh
  
## Лабораторная работа №4
- Вам  прекрасно  известно,  что  кошки  и  собаки  являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить  компьютеру  что  кошки  и  собаки  – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.
### Код
```python
class Mammal:
    className = 'Mammal'


class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'


class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'


dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Dog is {cat.className}, but they say {cat.sounds}")
```
### Результат
- если print(my_car.__model) активно
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Lab4_1.png)
- если print(my_car.__model) не активно
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Lab4_2.png)
### Выводы:
- Класс Car имеет два атрибута: _make и __model.
- Атрибут _make считается защищенным (по соглашению) и может быть доступен напрямую.
- Атрибут __model считается приватным, что усложняет прямой доступ извне класса. Попытка доступа к нему напрямую вызовет AttributeError.
- Метод drive выводит сообщение о том, что машина находится в движении, используя значения атрибутов _make и __model.
- print(my_car._make) выводит Lada
- print(my_car._make) выводит AttributeError

## Лабораторная работа №5
- На  разных  языках  здороваются  по-разному,  но  суть  остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих  языках.  А  также  напишем  функцию,  которая  будет  выводить информацию о том, как на этих языках здороваются.
Заметьте, что  для  решения  поставленной  задачи  мы  использовали декоратор  @staticmethod,  поскольку  нам  не  нужны  обязательные параметры-ссылки вроде self.
### Код
```python
class Russian:

    @staticmethod
    def greeting():
        print("Привет")


class English:

    @staticmethod
    def greeting():
        print("Hello")


def greet(language):
    language.greeting()


michael = Russian()
greet(michael)
john = English()
greet(john)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Lab5.png)
### Выводы:
- Определение базового класса 'Shape' с методом 'area'. Метод 'area' будет переопределен в подклассах.
- Определение подкласса 'Rectangle', наследующего от 'Shape' где реализуется метод-конструктор для инициализации ширины и высоты. Переопределение метода 'area' для вычисления площади прямоугольника.
- Определение еще одного подкласса 'Circle', также наследующего от 'Shape' где реализуется метод-конструктор для инициализации радиуса. Переопределение метода 'area' для вычисления площади круга.
- Создание объектов классов 'Rectangle' и 'Circle' и массива 'shapes', содержащего объекты 'rectangle' и 'circle'
- Перебор элементов массива 'shapes' и вывод площади каждой фигуры

## Самостоятельная работа №1
- Класс Tomato:
1) Создайте класс Tomato
2) Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
3) Создайте метод __init__(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states). После написания 
этого блока кода в комментарии к нему укажите какими являются 
эти два свойства
4) Создайте метод grow(), который будет переводить томат на 
следующую стадию созревания
5) Создайте метод is_ripe(), который будет проверять, что томат созрел
### Код
```python
#1)
class Tomato:
    # Создаем статическое свойство states, которое будет содержать все стадии созревания помидора
#2)
    states = {
        'none': 'отсутствует',
        'blossom': 'цветение',
        'green': 'зелёный',
        'red': 'красный'
    }

#3)
    def __init__(self, index):
        # Создаем два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states)
        self._index = index  # _index - это индекс помидора
        self._state = self.states['none']  # _state - это стадия созревания помидора, изначально он отсутствует
#4)
    def grow(self):
        # Метод grow() переводит томат на следующую стадию созревания
        if self._state == self.states['none']:
            self._state = self.states['blossom']
        elif self._state == self.states['blossom']:
            self._state = self.states['green']
        elif self._state == self.states['green']:
            self._state = self.states['red']
#5)
    def is_ripe(self):
        # Метод is_ripe() проверяет, что томат созрел
        return self._state == self.states['red']
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Sam1.png)
### Выводы:
- В этом коде создается класс Fruit, который имеет три атрибута: name, color и taste.
- Затем создаются три объекта класса Fruit - apple, banana и orange - с разными значениями атрибутов.
- Выводятся некоторые свойства этих объектов с помощью команды print.

## Самостоятельная работа №2
- Класс TomatoBush:
1) Создайте класс TomatoBush
2) Определите метод __init__(), который будет принимать в качестве 
параметра количество томатов и на его основе будет создавать 
список объектов класса Tomato. Данный список будет храниться 
внутри динамического свойства tomatoes
3) Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
4) Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми.
5) Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая
### Код
```python
class Tomato:
    # Создаем статическое свойство states, которое будет содержать все стадии созревания помидора
    states = {
        'none': 'отсутствует',
        'blossom': 'цветение',
        'green': 'зелёный',
        'red': 'красный'
    }

    def __init__(self, index):
        # Создаем два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states)
        self._index = index  # _index - это индекс помидора
        self._state = self.states['none']  # _state - это стадия созревания помидора, изначально он отсутствует

    def grow(self):
        # Метод grow() переводит томат на следующую стадию созревания
        if self._state == self.states['none']:
            self._state = self.states['blossom']
        elif self._state == self.states['blossom']:
            self._state = self.states['green']
        elif self._state == self.states['green']:
            self._state = self.states['red']
        #print(f"Помидор номер {self._index} созревает до стадии {self._state}")

    def is_ripe(self):
        # Метод is_ripe() проверяет, что томат созрел
        return self._state == self.states['red']

#1
class TomatoBush:
#2
    def __init__(self, num_tomatoes):
        # Определяем класс TomatoBush с динамическим свойством tomatoes - это список объектов класса Tomato
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]  # создаем список томатов
#3
    def grow_all(self):
        # Метод для перевода всех объектов из списка томатов на следующий этап созревания
        for tomato in self.tomatoes:
            tomato.grow()
        print(f"все томаты перешли на этап {tomato._state}") #ыводится если последний томат перешёл на следующий этап
#4
    def all_are_ripe(self):
        # Метод, который возвращает True, если все томаты из списка стали спелыми
        for tomato in self.tomatoes:
            if not tomato.is_ripe():
                return False
        return True
#5
    def give_away_all(self):
        # Метод, который чистит список томатов после сбора урожая
        self.tomatoes = []
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Sam2.png)
### Выводы:
- Создание класса Fruit, который имеет атрибуты name, color и taste, и метод properties(), который выводит информацию о фрукте на основе его атрибутов.
- Создание трёх объектов (apple, banana и orange) класса Fruit с различными свойствами (имя, цвет и вкус). Метод properties() вызывается для каждого объекта, чтобы вывести информацию о каждом фрукте.
  
## Самостоятельная работа №3
- Класс Gardener
1)Создайте класс Gardener
2) Создайте метод __init__(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3) Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
4) Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5) Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству
### Код
```python
class Tomato:
    # Создаем статическое свойство states, которое будет содержать все стадии созревания помидора
    states = {
        'none': 'отсутствует',
        'blossom': 'цветение',
        'green': 'зелёный',
        'red': 'красный'
    }

    def __init__(self, index):
        # Создаем два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states)
        self._index = index  # _index - это индекс помидора
        self._state = self.states['none']  # _state - это стадия созревания помидора, изначально он отсутствует

    def grow(self):
        # Метод grow() переводит томат на следующую стадию созревания
        if self._state == self.states['none']:
            self._state = self.states['blossom']
        elif self._state == self.states['blossom']:
            self._state = self.states['green']
        elif self._state == self.states['green']:
            self._state = self.states['red']
        #print(f"Помидор номер {self._index} созревает до стадии {self._state}")

    def is_ripe(self):
        # Метод is_ripe() проверяет, что томат созрел
        return self._state == self.states['red']

class TomatoBush:
    def __init__(self, num_tomatoes):
        # Определяем класс TomatoBush с динамическим свойством tomatoes - это список объектов класса Tomato
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]  # создаем список томатов

    def grow_all(self):
        # Метод для перевода всех объектов из списка томатов на следующий этап созревания
        for tomato in self.tomatoes:
            tomato.grow()
        print(f"все томаты перешли на этап {tomato._state}") #ыводится если последний томат перешёл на следующий этап

    def all_are_ripe(self):
        # Метод, который возвращает True, если все томаты из списка стали спелыми
        for tomato in self.tomatoes:
            if not tomato.is_ripe():
                return False
        return True

    def give_away_all(self):
        # Метод, который чистит список томатов после сбора урожая
        self.tomatoes = []

#1
class Gardener:
#2
    def __init__(self, name, plant):
        # Динамические свойства:
        # - name (передается параметром, является публичным)
        # - _plant (принимает объект класса TomatoBush)
        self.name = name  # имя садовника
        self._plant = plant  # растение, за которым ухаживает садовник
#3
    def work(self):
        # Метод work() заставляет садовника работать, что позволяет растению становиться более зрелым
        self._plant.grow_all()  # увеличиваем созревание всех помидоров на кусте
        print(f"садовник {self.name} хорошо поработал.")
#4
    def harvest(self):
        # Метод harvest() проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
        if self._plant.all_are_ripe():
            print(f"{self.name} собирает урожай!")
            self._plant.give_away_all()  # сбрасываем состояние всех помидоров
        else:
            print("Предупреждение: Не все помидоры созрели, нельзя собирать урожай!")
#5
    @staticmethod
    def knowledge_base():
        # Статический метод knowledge_base() выводит в консоль справку по садоводству
        print("Садоводство - это искусство выращивания растений в саду или огороде с целью получения урожая.")
        print("Садовод должен ухаживать за растениями, обрабатывать почву, поливать и удобрять их для успешного выращивания.")
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Sam3.png)
### Выводы:
- Создание класса Fruit который определяет основные характеристики фруктов, такие как имя, цвет и вкус.
- Создание класса ExoticFruit. Класс ExoticFruit является подклассом Fruit и добавляет новое свойство - популярное место для выращивания фрукта. Метод properties() в каждом классе выводит информацию о фрукте, его цвете, вкусе и в случае экзотических фруктов - о популярном месте для выращивания.
- Пример использования этих классов демонстрируется созданием экземпляра pineapple (ананаса) и вызовом метода properties(), чтобы вывести информацию об ананасе, включая его свойства и популярное место для выращивания.
  
## Самостоятельная работа №4
- Тесты:
1) Вызовите справку по садоводству
2) Создайте объекты классов TomatoBush и Gardener
3) Используя объект класса Gardener, поухаживайте за кустом с помидорами
4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
5) Соберите урожай
### Код
```python
class Tomato:
    # Создаем статическое свойство states, которое будет содержать все стадии созревания помидора
    states = {
        'none': 'отсутствует',
        'blossom': 'цветение',
        'green': 'зелёный',
        'red': 'красный'
    }

    def __init__(self, index):
        # Создаем два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states)
        self._index = index  # _index - это индекс помидора
        self._state = self.states['none']  # _state - это стадия созревания помидора, изначально он отсутствует

    def grow(self):
        # Метод grow() переводит томат на следующую стадию созревания
        if self._state == self.states['none']:
            self._state = self.states['blossom']
        elif self._state == self.states['blossom']:
            self._state = self.states['green']
        elif self._state == self.states['green']:
            self._state = self.states['red']
        #print(f"Помидор номер {self._index} созревает до стадии {self._state}")

    def is_ripe(self):
        # Метод is_ripe() проверяет, что томат созрел
        return self._state == self.states['red']

class TomatoBush:
    def __init__(self, num_tomatoes):
        # Определяем класс TomatoBush с динамическим свойством tomatoes - это список объектов класса Tomato
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]  # создаем список томатов

    def grow_all(self):
        # Метод для перевода всех объектов из списка томатов на следующий этап созревания
        for tomato in self.tomatoes:
            tomato.grow()
        print(f"все томаты перешли на этап {tomato._state}") #ыводится если последний томат перешёл на следующий этап

    def all_are_ripe(self):
        # Метод, который возвращает True, если все томаты из списка стали спелыми
        for tomato in self.tomatoes:
            if not tomato.is_ripe():
                return False
        return True

    def give_away_all(self):
        # Метод, который чистит список томатов после сбора урожая
        self.tomatoes = []


class Gardener:
    def __init__(self, name, plant):
        # Динамические свойства:
        # - name (передается параметром, является публичным)
        # - _plant (принимает объект класса TomatoBush)
        self.name = name  # имя садовника
        self._plant = plant  # растение, за которым ухаживает садовник

    def work(self):
        # Метод work() заставляет садовника работать, что позволяет растению становиться более зрелым
        self._plant.grow_all()  # увеличиваем созревание всех помидоров на кусте
        print(f"садовник {self.name} хорошо поработал.")

    def harvest(self):
        # Метод harvest() проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
        if self._plant.all_are_ripe():
            print(f"{self.name} собирает урожай!")
            self._plant.give_away_all()  # сбрасываем состояние всех помидоров
        else:
            print("Предупреждение: Не все помидоры созрели, нельзя собирать урожай!")

    @staticmethod
    def knowledge_base():
        # Статический метод knowledge_base() выводит в консоль справку по садоводству
        print("Садоводство - это искусство выращивания растений в саду или огороде с целью получения урожая.")
        print("Садовод должен ухаживать за растениями, обрабатывать почву, поливать и удобрять их для успешного выращивания.")


#1)
print('#1')
Gardener.knowledge_base()   #Вызов справки по садоводству

#2)
print('#2')
tomat = TomatoBush(6) #Вызов объектов класса TomatoBush
gardener = Gardener('Михаил', tomat)    #Вызов объектов класса Gardener

#3)
print('#3')
gardener.work() #созревание помидоров, этап цветения

#4)
print('#4')
gardener.harvest() #попытка сбора несозревшего урожая, ,будет выведено сообщение "Предупреждение: Не все помидоры созрели, нельзя собирать урожай!"

#5)
print('#5')
gardener.work() #этап зеленые помидоры
gardener.work() #красные помидоры
gardener.harvest() #сбор урожая


```
### Результат
- если print(apple.__tasty) активно
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Sam4_1.png)
- если print(apple.__tasty) не активно
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/Sam4_2.png)
### Выводы:
- Создание класс Fruit, который содержит атрибуты _name, _color, и __taste, и метод properties(), который возвращает строку, описывающую свойства фрукта.
- Создается объект apple типа Fruit, представляющий яблоко с атрибутами "Яблоко", "красный" и "сладкий".
- print(apple._name) выводит значение атрибута _name объекта apple, что будет "Яблоко".
- Однако, при попытке вывести print(apple.__tasty) возникнет ошибка, так как атрибут __taste объявлен как закрытый (private) с использованием двойного подчеркивания перед именем (__taste). Доступ к закрытым атрибутам напрямую извне класса невозможен.

## Общие выводы по теме
- Классы позволяют создавать новые типы данных, описывая их состояние (атрибуты) и поведение (методы). Классы являются шаблонами, на основе которых можно создавать экземпляры (объекты).
- Подклассы (или дочерние классы) могут наследовать атрибуты и методы от родительских классов, расширяя их или переопределяя. Это позволяет избежать дублирования кода и повышает его повторное использование.
- Кроме того, классы и подклассы позволяют работать с полиморфизмом, что означает использование объектов разных классов через общий интерфейс.
- Использование классов и подклассов делает код более структурированным, упрощает его поддержку и понимание, позволяет создавать мощные и гибкие приложения.
