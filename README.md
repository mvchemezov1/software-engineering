# Тема 9.  Концепции и принципы ООП
Отчет по Теме #9 выполнил:
- Чемезов Михаил Владимирович
- АИС-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + |   |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
-  Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте  класс,  указав  в  свойствах  только  имя.  Дальше  создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав  атрибут,  который  не  указан  в  вашем  классе,  например, попробуйте вызвать фамилию.
### Код
```python
class Michael:
    __slots__ = ['name']

    def __init__(self, name):
        if name == 'Михаил':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Да, я {name}"

person1 = Michael('Алексей')
person2 = Michael('Михаил')
print(person1.name)
print(person2.name)

person2.surname = 'Чемезов'
print(person2.surname)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Lab1.png)
### Вывод:
- В данном коде объявлен класс "Michael", который имеет атрибут "slots" со значением ['name']. Атрибут "slots" используется для определения фиксированного множества атрибутов для экземпляра класса. В данном случае, экземпляры класса "Michael" могут иметь только атрибут "name".
- В конструкторе класса "init" определен метод инициализации экземпляра. Он принимает аргумент "name" и проверяет, является ли значение "name" равным строке 'Михаил'. Если условие выполняется, то атрибут "name" экземпляра класса устанавливается как "Да, я Михаил". В противном случае, атрибут "name" устанавливается как "Да, я {name}".
- Создаются два экземпляра класса "Michael": "person1" с именем 'Алексей' и "person2" с именем 'Михаил'.
- Выводится значение атрибута "name" для "person1" и "person2".
- Далее выполнение кода пытается установить атрибут "surname" для "person2". Однако, поскольку "surname" не определен в slots, это приведет к ошибке.

## Лабораторная работа №2
- Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте  метод,  выводящий  на  печать  «Мороженое  с {ТОППИНГ}»  в  случае  наличия  добавки,  а  иначе  отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.
### Код
```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print('Обычное мороженое')


icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадное')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Lab2.png)
### Вывод:
- Создается класс "Icecream". Внутри класса определен метод "init", который является конструктором инициализации экземпляра. Он принимает один аргумент "ingredient" по умолчанию равный None. Внутри конструктора проверяется, является ли "ingredient" строкой. Если "ingredient" является строкой, то атрибут "self.ingredient" устанавливается равным переданной строке. В противном случае, "self.ingredient" устанавливается равным None.
- В классе также определен метод "composition", который выводит состав мороженого, основываясь на атрибуте "ingredient". Если "ingredient" не является None, то выводится сообщение о мороженом с указанным ингредиентом. Иначе выводится сообщение о обычном мороженом.
- Создается экземпляр класса "Icecream" с именем "icecream".
- Вызывается метод "composition" для объекта "icecream". Поскольку при создании объекта не был передан ингредиент, будет выведено сообщение о обычном мороженом.
- Создается новый объект "icecream" с ингредиентом 'шоколадное'.
- Затем вызывается метод "composition" для этого нового объекта "icecream", и будет выведено сообщение о мороженом с ингредиентом 'шоколадное'.
- Создается еще один объект "icecream" с аргументом 5, который не является строкой.
- Вызывается метод "composition" для этого нового объекта "icecream", и будет выведено сообщение о обычном мороженом, так как "ingredient" не является строкой.

## Лабораторная работа №3
- Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.
Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.
### Код
```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):     #установка значения атрибута
        self._value = value

    def get_value(self):    #получение значения атрибута
        return self._value

    def del_value(self):    #удаление атрибута
        del self._value

    value = property(get_value, set_value, del_value, 'Свойство value')

obj = MyClass(42)
print(obj.get_value())
obj = MyClass(45)
print(obj.get_value())
obj = MyClass(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Lab3.png)
### Выводы:
- Создается класс "MyClass", который содержит методы init, set_value, get_value и del_value, а также свойство "value".
- Метод init принимает один аргумент "value" и инициализирует атрибут класса "_value" значением "value".
- Метод set_value устанавливает новое значение атрибута "_value".
- Метод get_value возвращает текущее значение атрибута "_value".
- Метод del_value удаляет атрибут "_value".
- Свойство "value" создается с помощью функции property, которая связывает методы get_value, set_value и del_value с атрибутом "value". Это позволяет обращаться к атрибуту "value" как к обычной переменной, хотя за кулисами вызываются соответствующие методы.
- Создается объект "obj" класса "MyClass" с начальным значением 42.
- Вызывается метод get_value() для объекта "obj", и выводится текущее значение атрибута "_value", то есть 42.
- Создается новый объект "obj" класса "MyClass" с начальным значением 45.
- Вызывается снова метод get_value() для объекта "obj", и выводится текущее значение атрибута "_value", то есть 45.
- Создается еще один объект "obj" класса "MyClass", на этот раз с начальным значением 100.
- Вызывается снова метод get_value() для объекта "obj", и выводится текущее значение атрибута "_value", то есть 100.
- Вызывается метод del_value() для объекта "obj", после чего вызывается метод get_value() снова. Это вызовет ошибку, так как атрибут "_value" был удален.
  
## Лабораторная работа №4
- Вам  прекрасно  известно,  что  кошки  и  собаки  являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить  компьютеру  что  кошки  и  собаки  – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.
### Код
```python
class Mammal:
    className = 'Mammal'


class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'


class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'


dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Dog is {cat.className}, but they say {cat.sounds}")
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Lab4.png)
### Выводы:
- Определяется класс "Mammal" с атрибутом "className", установленным в значение "Mammal".
- Определяется класс "Dog", который наследует от класса "Mammal". У него есть атрибуты "species", установленный в значение "canine", и "sounds", установленный в значение "wow".
- Определяется класс "Cat", который также наследует от класса "Mammal". У него есть атрибуты "species", установленный в значение "feline", и "sounds", установленный в значение "meow".
- мСоздается объект "dog" класса "Dog" с использованием пустых скобок, что вызывает конструктор класса по умолчанию.
- Выводится сообщение с использованием f-строки, которая обращается к атрибутам "className" и "sounds" объекта "dog" и выводит информацию о классе и звуке, который издает собака.
- Создается объект "cat" класса "Cat" таким же образом.
- Выводится сообщение с использованием f-строки, которая обращается к атрибутам "className" и "sounds" объекта "cat" и выводит информацию о классе и звуке, который издает кошка.
- код показывает использование наследования в ООП.

## Лабораторная работа №5
- На  разных  языках  здороваются  по-разному,  но  суть  остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих  языках.  А  также  напишем  функцию,  которая  будет  выводить информацию о том, как на этих языках здороваются.
Заметьте, что  для  решения  поставленной  задачи  мы  использовали декоратор  @staticmethod,  поскольку  нам  не  нужны  обязательные параметры-ссылки вроде self.
### Код
```python
class Russian:

    @staticmethod
    def greeting():
        print("Привет")


class English:

    @staticmethod
    def greeting():
        print("Hello")


def greet(language):
    language.greeting()


michael = Russian()
greet(michael)
john = English()
greet(john)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Lab5.png)
### Выводы:
- Определяется класс "Russian" с использованием декоратора @staticmethod над методом "greeting()". Этот метод выводит строку "Привет" на экран.
- Определяется класс "English" с использованием декоратора @staticmethod над методом "greeting()". Этот метод выводит строку "Hello" на экран.
- Создается функция "greet", которая принимает параметр "language". Эта функция вызывает метод "greeting()" объекта "language".
- Создается объект "michael" класса "Russian".
- Вызывается функция "greet" с объектом "michael" в качестве аргумента. Это вызывает метод "greeting()" класса "Russian" и выводит "Привет" на экран.
- Создается объект "john" класса "English".
- Вызывается функция "greet" с объектом "john" в качестве аргумента. Это вызывает метод "greeting()" класса "English" и выводит "Hello" на экран.
- код демонстрирует принцип полиморфизма в ООП. Функция "greet" вызывает метод "greeting()" объекта, представляющего различные языки приветствия.

## Самостоятельная работа №1
- Класс Tomato:
1) Создайте класс Tomato
2) Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
3) Создайте метод __init__(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states). После написания 
этого блока кода в комментарии к нему укажите какими являются 
эти два свойства
4) Создайте метод grow(), который будет переводить томат на 
следующую стадию созревания
5) Создайте метод is_ripe(), который будет проверять, что томат созрел
### Код
```python
#1)
class Tomato:
    # Создаем статическое свойство states, которое будет содержать все стадии созревания помидора
#2)
    states = {
        'none': 'отсутствует',
        'blossom': 'цветение',
        'green': 'зелёный',
        'red': 'красный'
    }

#3)
    def __init__(self, index):
        # Создаем два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states)
        self._index = index  # _index - это индекс помидора
        self._state = self.states['none']  # _state - это стадия созревания помидора, изначально он отсутствует
#4)
    def grow(self):
        # Метод grow() переводит томат на следующую стадию созревания
        if self._state == self.states['none']:
            self._state = self.states['blossom']
        elif self._state == self.states['blossom']:
            self._state = self.states['green']
        elif self._state == self.states['green']:
            self._state = self.states['red']
#5)
    def is_ripe(self):
        # Метод is_ripe() проверяет, что томат созрел
        return self._state == self.states['red']
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Sam1.png)
### Выводы:
- Определяется класс "Tomato" с созданием статического свойства "states", которое содержит все стадии созревания помидора.
- Статическое свойство "states" содержит словарь с ключами 'none', 'blossom', 'green', 'red', соответствующими стадиям созревания.
- Определяется метод "init", который инициализирует объект класса "Tomato" с двумя динамическими свойствами: "_index" (принимает значение параметра "index") и "_state" (принимает первое значение из словаря states, в данном случае - 'none').
- Определяется метод "grow()", который переводит помидор на следующую стадию созревания, в зависимости от его текущего состояния.
- Определяется метод "is_ripe()", который проверяет, что помидор созрел, возвращая булево значение True, если текущее состояние помидора равно 'red', иначе возвращает False.

## Самостоятельная работа №2
- Класс TomatoBush:
1) Создайте класс TomatoBush
2) Определите метод __init__(), который будет принимать в качестве 
параметра количество томатов и на его основе будет создавать 
список объектов класса Tomato. Данный список будет храниться 
внутри динамического свойства tomatoes
3) Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
4) Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми.
5) Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая
### Код
```python
class Tomato:
    # Создаем статическое свойство states, которое будет содержать все стадии созревания помидора
    states = {
        'none': 'отсутствует',
        'blossom': 'цветение',
        'green': 'зелёный',
        'red': 'красный'
    }

    def __init__(self, index):
        # Создаем два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states)
        self._index = index  # _index - это индекс помидора
        self._state = self.states['none']  # _state - это стадия созревания помидора, изначально он отсутствует

    def grow(self):
        # Метод grow() переводит томат на следующую стадию созревания
        if self._state == self.states['none']:
            self._state = self.states['blossom']
        elif self._state == self.states['blossom']:
            self._state = self.states['green']
        elif self._state == self.states['green']:
            self._state = self.states['red']
        #print(f"Помидор номер {self._index} созревает до стадии {self._state}")

    def is_ripe(self):
        # Метод is_ripe() проверяет, что томат созрел
        return self._state == self.states['red']

#1
class TomatoBush:
#2
    def __init__(self, num_tomatoes):
        # Определяем класс TomatoBush с динамическим свойством tomatoes - это список объектов класса Tomato
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]  # создаем список томатов
#3
    def grow_all(self):
        # Метод для перевода всех объектов из списка томатов на следующий этап созревания
        for tomato in self.tomatoes:
            tomato.grow()
        print(f"все томаты перешли на этап {tomato._state}") #ыводится если последний томат перешёл на следующий этап
#4
    def all_are_ripe(self):
        # Метод, который возвращает True, если все томаты из списка стали спелыми
        for tomato in self.tomatoes:
            if not tomato.is_ripe():
                return False
        return True
#5
    def give_away_all(self):
        # Метод, который чистит список томатов после сбора урожая
        self.tomatoes = []
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Sam2.png)
### Выводы:
- Определен класс "TomatoBush", который представляет куст помидоров.
- В методе "init" класса "TomatoBush" создается динамическое свойство "tomatoes" - это список объектов класса "Tomato", который создается с помощью генератора списков. Создается список томатов в количестве, указанном в параметре "num_tomatoes". Каждый томат имеет порядковый номер от 1 до "num_tomatoes".
- Метод "grow_all" позволяет перевести все томаты куста на следующий этап созревания. Для каждого томата в списке "tomatoes" вызывается метод "grow()", переводящий томат на следующий этап созревания. Затем выводится сообщение о том, что все томаты перешли на следующий этап созревания (при условии, что последний томат перешел на следующий этап).
- Метод "all_are_ripe" проверяет, все ли томаты из списка стали спелыми. Если хотя бы один томат не спелый, метод возвращает False, иначе возвращает True.
- Метод "give_away_all" очищает список томатов после сбора урожая, присваивая ему пустой список.
  
## Самостоятельная работа №3
- Класс Gardener
1)Создайте класс Gardener
2) Создайте метод __init__(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3) Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
4) Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5) Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству
### Код
```python
class Tomato:
    # Создаем статическое свойство states, которое будет содержать все стадии созревания помидора
    states = {
        'none': 'отсутствует',
        'blossom': 'цветение',
        'green': 'зелёный',
        'red': 'красный'
    }

    def __init__(self, index):
        # Создаем два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states)
        self._index = index  # _index - это индекс помидора
        self._state = self.states['none']  # _state - это стадия созревания помидора, изначально он отсутствует

    def grow(self):
        # Метод grow() переводит томат на следующую стадию созревания
        if self._state == self.states['none']:
            self._state = self.states['blossom']
        elif self._state == self.states['blossom']:
            self._state = self.states['green']
        elif self._state == self.states['green']:
            self._state = self.states['red']
        #print(f"Помидор номер {self._index} созревает до стадии {self._state}")

    def is_ripe(self):
        # Метод is_ripe() проверяет, что томат созрел
        return self._state == self.states['red']

class TomatoBush:
    def __init__(self, num_tomatoes):
        # Определяем класс TomatoBush с динамическим свойством tomatoes - это список объектов класса Tomato
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]  # создаем список томатов

    def grow_all(self):
        # Метод для перевода всех объектов из списка томатов на следующий этап созревания
        for tomato in self.tomatoes:
            tomato.grow()
        print(f"все томаты перешли на этап {tomato._state}") #ыводится если последний томат перешёл на следующий этап

    def all_are_ripe(self):
        # Метод, который возвращает True, если все томаты из списка стали спелыми
        for tomato in self.tomatoes:
            if not tomato.is_ripe():
                return False
        return True

    def give_away_all(self):
        # Метод, который чистит список томатов после сбора урожая
        self.tomatoes = []

#1
class Gardener:
#2
    def __init__(self, name, plant):
        # Динамические свойства:
        # - name (передается параметром, является публичным)
        # - _plant (принимает объект класса TomatoBush)
        self.name = name  # имя садовника
        self._plant = plant  # растение, за которым ухаживает садовник
#3
    def work(self):
        # Метод work() заставляет садовника работать, что позволяет растению становиться более зрелым
        self._plant.grow_all()  # увеличиваем созревание всех помидоров на кусте
        print(f"садовник {self.name} хорошо поработал.")
#4
    def harvest(self):
        # Метод harvest() проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
        if self._plant.all_are_ripe():
            print(f"{self.name} собирает урожай!")
            self._plant.give_away_all()  # сбрасываем состояние всех помидоров
        else:
            print("Предупреждение: Не все помидоры созрели, нельзя собирать урожай!")
#5
    @staticmethod
    def knowledge_base():
        # Статический метод knowledge_base() выводит в консоль справку по садоводству
        print("Садоводство - это искусство выращивания растений в саду или огороде с целью получения урожая.")
        print("Садовод должен ухаживать за растениями, обрабатывать почву, поливать и удобрять их для успешного выращивания.")
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Sam3.png)
### Выводы:
- Создан класс "Gardener" для представления садовника.
- В методе "init" класса "Gardener" определены динамические свойства: "name" (передается параметром и является публичным) и "_plant" (принимает объект класса TomatoBush).
- Метод "work" заставляет садовника работать. Для этого вызывается метод "grow_all" у объекта "_plant", увеличивающий созревание всех помидоров на кусте. После этого выводится сообщение о том, что садовник поработал.
- Метод "harvest" проверяет, все ли плоды созрели. Если да, то садовник собирает урожай, вызывая метод "give_away_all" у объекта "_plant", который сбрасывает состояние всех помидоров. Если не все помидоры созрели, то выводится предупреждение.
- В статическом методе "knowledge_base" выводится справка по садоводству, содержащая информацию об искусстве выращивания растений, уходе за ними, обработке почвы и других аспектах садоводства.
  
## Самостоятельная работа №4
- Тесты:
1) Вызовите справку по садоводству
2) Создайте объекты классов TomatoBush и Gardener
3) Используя объект класса Gardener, поухаживайте за кустом с помидорами
4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
5) Соберите урожай
### Код
```python
class Tomato:
    # Создаем статическое свойство states, которое будет содержать все стадии созревания помидора
    states = {
        'none': 'отсутствует',
        'blossom': 'цветение',
        'green': 'зелёный',
        'red': 'красный'
    }

    def __init__(self, index):
        # Создаем два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states)
        self._index = index  # _index - это индекс помидора
        self._state = self.states['none']  # _state - это стадия созревания помидора, изначально он отсутствует

    def grow(self):
        # Метод grow() переводит томат на следующую стадию созревания
        if self._state == self.states['none']:
            self._state = self.states['blossom']
        elif self._state == self.states['blossom']:
            self._state = self.states['green']
        elif self._state == self.states['green']:
            self._state = self.states['red']
        #print(f"Помидор номер {self._index} созревает до стадии {self._state}")

    def is_ripe(self):
        # Метод is_ripe() проверяет, что томат созрел
        return self._state == self.states['red']

class TomatoBush:
    def __init__(self, num_tomatoes):
        # Определяем класс TomatoBush с динамическим свойством tomatoes - это список объектов класса Tomato
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]  # создаем список томатов

    def grow_all(self):
        # Метод для перевода всех объектов из списка томатов на следующий этап созревания
        for tomato in self.tomatoes:
            tomato.grow()
        print(f"все томаты перешли на этап {tomato._state}") #ыводится если последний томат перешёл на следующий этап

    def all_are_ripe(self):
        # Метод, который возвращает True, если все томаты из списка стали спелыми
        for tomato in self.tomatoes:
            if not tomato.is_ripe():
                return False
        return True

    def give_away_all(self):
        # Метод, который чистит список томатов после сбора урожая
        self.tomatoes = []


class Gardener:
    def __init__(self, name, plant):
        # Динамические свойства:
        # - name (передается параметром, является публичным)
        # - _plant (принимает объект класса TomatoBush)
        self.name = name  # имя садовника
        self._plant = plant  # растение, за которым ухаживает садовник

    def work(self):
        # Метод work() заставляет садовника работать, что позволяет растению становиться более зрелым
        self._plant.grow_all()  # увеличиваем созревание всех помидоров на кусте
        print(f"садовник {self.name} хорошо поработал.")

    def harvest(self):
        # Метод harvest() проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
        if self._plant.all_are_ripe():
            print(f"{self.name} собирает урожай!")
            self._plant.give_away_all()  # сбрасываем состояние всех помидоров
        else:
            print("Предупреждение: Не все помидоры созрели, нельзя собирать урожай!")

    @staticmethod
    def knowledge_base():
        # Статический метод knowledge_base() выводит в консоль справку по садоводству
        print("Садоводство - это искусство выращивания растений в саду или огороде с целью получения урожая.")
        print("Садовод должен ухаживать за растениями, обрабатывать почву, поливать и удобрять их для успешного выращивания.")


#1)
print('#1')
Gardener.knowledge_base()   #Вызов справки по садоводству

#2)
print('#2')
tomat = TomatoBush(6) #Вызов объектов класса TomatoBush
gardener = Gardener('Михаил', tomat)    #Вызов объектов класса Gardener

#3)
print('#3')
gardener.work() #созревание помидоров, этап цветения

#4)
print('#4')
gardener.harvest() #попытка сбора несозревшего урожая, ,будет выведено сообщение "Предупреждение: Не все помидоры созрели, нельзя собирать урожай!"

#5)
print('#5')
gardener.work() #этап зеленые помидоры
gardener.work() #красные помидоры
gardener.harvest() #сбор урожая


```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Sam4.png)
### Выводы:
- Вызов справки по садоводству с помощью статического метода "knowledge_base"
- Создание объектов tomat и gardener классов TomatoBush и Gardener
- Вызов метода work что заставит садовника поработать
- Вызов метода harvest, попытка сбора несозревшего урожая
- несколько вызовов метода work, до полного созревания томатов и затем с помощью метода harvest осуществляется сбор урожая

## Общие выводы по теме
- В данной работе мы использовали наследование, инкапсуляцию, полиморфизм и абстракцию.
- Наследование позволяет создавать новые классы на основе уже существующих, заимствуя их свойства и методы. Это помогает сделать код более модульным и уменьшить его дублирование.
- Инкапсуляция позволяет объединить данные и методы, обрабатывающие их, в одном объекте. Это способствует контролю доступа к данным, предотвращая их нежелательное изменение извне, и обеспечивает защиту от некорректного использования.
- Полиморфизм позволяет одним и тем же именам методов использоваться в разных контекстах, что упрощает работу с различными типами
