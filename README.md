# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил:
- Чемезов Михаил Владимирович
- АИС-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
- Наверняка вы думаете, что декораторы – это какая-то бесполезная 
вещь, которая вам никогда не пригодится, но тут вдруг на паре по 
математике преподаватель просит всех посчитать число Фибоначчи для 100. Кто-то будет считать вручную (так точно не нужно), кто-то 
посчитает на калькуляторе, а кто-то подумает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, 
потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно тут к вам на помощь приходят 
декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот 
декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программа не будет считать одни и те же значения, а просто “возьмёт их из этого декоратора”). Вам нужно написать 
программу, которая будет считать числа Фибоначчи для 100 и 
запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи.
P.S. при запуске без декоратора можете долго не ждать, для наглядности хватит 10 секунд ожидания.
### Код
- Без декоратора
```python
from functools import lru_cache


#@lru_cache(None) #декоратор динамического программирования
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n - 2)


if __name__ == '__main__':
    print(fibonacci(100))
```

- С декоратором
```python
from functools import lru_cache


#@lru_cache(None) #декоратор динамического программирования
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n - 2)


if __name__ == '__main__':
    print(fibonacci(100))
```

### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Lab1.png)
### Вывод:
- В данном коде объявлен класс "Michael", который имеет атрибут "slots" со значением ['name']. Атрибут "slots" используется для определения фиксированного множества атрибутов для экземпляра класса. В данном случае, экземпляры класса "Michael" могут иметь только атрибут "name".
- В конструкторе класса "init" определен метод инициализации экземпляра. Он принимает аргумент "name" и проверяет, является ли значение "name" равным строке 'Михаил'. Если условие выполняется, то атрибут "name" экземпляра класса устанавливается как "Да, я Михаил". В противном случае, атрибут "name" устанавливается как "Да, я {name}".
- Создаются два экземпляра класса "Michael": "person1" с именем 'Алексей' и "person2" с именем 'Михаил'.
- Выводится значение атрибута "name" для "person1" и "person2".
- Далее выполнение кода пытается установить атрибут "surname" для "person2". Однако, поскольку "surname" не определен в slots, это приведет к ошибке.

## Лабораторная работа №2
- Илья пишет свой сайт и ему необходимо сделать минимальную 
проверку ввода данных пользователя при регистрации. Для этого он 
реализовал функцию, которая выводит данные пользователя на экран и решил, что будет проверять правильность введённых данных при 
помощи декоратора, но в этом ему потребовалась ваша помощь. 
Напишите декоратор для функции, который будет принимать все 
параметры вызываемой функции (имя, возраст) и проверять чтобы 
возраст был больше 0 и меньше 130.
Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента.
### Код
```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func


@check
def personal_info(name, age):
    print(f"Name: {name}, Age: {age}")


if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Петр', 138, 15, 48, 2)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Lab2.png)
### Вывод:
- Создается класс "Icecream". Внутри класса определен метод "init", который является конструктором инициализации экземпляра. Он принимает один аргумент "ingredient" по умолчанию равный None. Внутри конструктора проверяется, является ли "ingredient" строкой. Если "ingredient" является строкой, то атрибут "self.ingredient" устанавливается равным переданной строке. В противном случае, "self.ingredient" устанавливается равным None.
- В классе также определен метод "composition", который выводит состав мороженого, основываясь на атрибуте "ingredient". Если "ingredient" не является None, то выводится сообщение о мороженом с указанным ингредиентом. Иначе выводится сообщение о обычном мороженом.
- Создается экземпляр класса "Icecream" с именем "icecream".
- Вызывается метод "composition" для объекта "icecream". Поскольку при создании объекта не был передан ингредиент, будет выведено сообщение о обычном мороженом.
- Создается новый объект "icecream" с ингредиентом 'шоколадное'.
- Затем вызывается метод "composition" для этого нового объекта "icecream", и будет выведено сообщение о мороженом с ингредиентом 'шоколадное'.
- Создается еще один объект "icecream" с аргументом 5, который не является строкой.
- Вызывается метод "composition" для этого нового объекта "icecream", и будет выведено сообщение о обычном мороженом, так как "ingredient" не является строкой.

## Лабораторная работа №3
- Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то 
пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер 
пытается все сломать и вместо нужного типа данных отправляет string.Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт.
Также дополнительно можете обернуть весь код функции в 
try/except/finally для того, чтобы программа вас оповестила о том, что выявлена какая-то ошибка или программа успешно выполнена.
### Код
```python
def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')


if __name__ == '__main__':
    data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Lab3.png)
### Выводы:
- Создается класс "MyClass", который содержит методы init, set_value, get_value и del_value, а также свойство "value".
- Метод init принимает один аргумент "value" и инициализирует атрибут класса "_value" значением "value".
- Метод set_value устанавливает новое значение атрибута "_value".
- Метод get_value возвращает текущее значение атрибута "_value".
- Метод del_value удаляет атрибут "_value".
- Свойство "value" создается с помощью функции property, которая связывает методы get_value, set_value и del_value с атрибутом "value". Это позволяет обращаться к атрибуту "value" как к обычной переменной, хотя за кулисами вызываются соответствующие методы.
- Создается объект "obj" класса "MyClass" с начальным значением 42.
- Вызывается метод get_value() для объекта "obj", и выводится текущее значение атрибута "_value", то есть 42.
- Создается новый объект "obj" класса "MyClass" с начальным значением 45.
- Вызывается снова метод get_value() для объекта "obj", и выводится текущее значение атрибута "_value", то есть 45.
- Создается еще один объект "obj" класса "MyClass", на этот раз с начальным значением 100.
- Вызывается снова метод get_value() для объекта "obj", и выводится текущее значение атрибута "_value", то есть 100.
- Вызывается метод del_value() для объекта "obj", после чего вызывается метод get_value() снова. Это вызовет ошибку, так как атрибут "_value" был удален.
  
## Лабораторная работа №4
- Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводиться “Успешная регистрация”
### Код
```python
class NegativeValueException(Exception):
    pass


def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')


if __name__ == '__main__':
    name = '12345678910'
    check_name(name)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Lab4.png)
### Выводы:
- Определяется класс "Mammal" с атрибутом "className", установленным в значение "Mammal".
- Определяется класс "Dog", который наследует от класса "Mammal". У него есть атрибуты "species", установленный в значение "canine", и "sounds", установленный в значение "wow".
- Определяется класс "Cat", который также наследует от класса "Mammal". У него есть атрибуты "species", установленный в значение "feline", и "sounds", установленный в значение "meow".
- мСоздается объект "dog" класса "Dog" с использованием пустых скобок, что вызывает конструктор класса по умолчанию.
- Выводится сообщение с использованием f-строки, которая обращается к атрибутам "className" и "sounds" объекта "dog" и выводит информацию о классе и звуке, который издает собака.
- Создается объект "cat" класса "Cat" таким же образом.
- Выводится сообщение с использованием f-строки, которая обращается к атрибутам "className" и "sounds" объекта "cat" и выводит информацию о классе и звуке, который издает кошка.
- код показывает использование наследования в ООП.

## Лабораторная работа №5
- После запуска сайта вы поняли, что вам необходимо добавить логгер, для отслеживания его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для этого создали две функции: __init__() (вызывается при создании класса декоратора в программе) и __call__() (вызывается при вызове 
декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль.
### Код
```python
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного подключения')


@SiteChecker
def site():
    print('Усердная работа сайта')

if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Lab5.png)
### Выводы:
- Определяется класс "Russian" с использованием декоратора @staticmethod над методом "greeting()". Этот метод выводит строку "Привет" на экран.
- Определяется класс "English" с использованием декоратора @staticmethod над методом "greeting()". Этот метод выводит строку "Hello" на экран.
- Создается функция "greet", которая принимает параметр "language". Эта функция вызывает метод "greeting()" объекта "language".
- Создается объект "michael" класса "Russian".
- Вызывается функция "greet" с объектом "michael" в качестве аргумента. Это вызывает метод "greeting()" класса "Russian" и выводит "Привет" на экран.
- Создается объект "john" класса "English".
- Вызывается функция "greet" с объектом "john" в качестве аргумента. Это вызывает метод "greeting()" класса "English" и выводит "Hello" на экран.
- код демонстрирует принцип полиморфизма в ООП. Функция "greet" вызывает метод "greeting()" объекта, представляющего различные языки приветствия.

## Самостоятельная работа №1
- Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. 
Он решил, что для этого ему идеально подойдет декоратор для 
функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор.
Подсказка: необходимо использовать модуль time
Декоратор необходимо использовать для этой функции:
```python
def fibonacci():
  fib1 = fib2 = 1

  for i in range(2, 200):
    fib1, fib2 = fib2, fib1 + fib2
    print(fib2, end=' ')

if __name__ == '__main__': fibonacci()
```
Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы.
Также на этом примере можете посмотреть, что решение задач через рекурсию не всегда является хорошей идеей. Поскольку решение 
Фибоначчи для 100 с использованием рекурсии и без динамического программирования решается более десяти секунд, а решение точно такой же задачи, но через цикл for еще и для 200, занимает меньше 1 секунды.
### Код
```python
#1)
import time

def calculate_time(func):
    def wrapper():
        start_time = time.time()
        func()
        end_time = time.time()
        print(f"Время выполнения функции: {end_time - start_time} секунд")
    return wrapper

@calculate_time
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')

if __name__ == '__main__':
    fibonacci()
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Sam1.png)
### Выводы:
- Определяется класс "Tomato" с созданием статического свойства "states", которое содержит все стадии созревания помидора.
- Статическое свойство "states" содержит словарь с ключами 'none', 'blossom', 'green', 'red', соответствующими стадиям созревания.
- Определяется метод "init", который инициализирует объект класса "Tomato" с двумя динамическими свойствами: "_index" (принимает значение параметра "index") и "_state" (принимает первое значение из словаря states, в данном случае - 'none').
- Определяется метод "grow()", который переводит помидор на следующую стадию созревания, в зависимости от его текущего состояния.
- Определяется метод "is_ripe()", который проверяет, что помидор созрел, возвращая булево значение True, если текущее состояние помидора равно 'red', иначе возвращает False.

## Самостоятельная работа №2
- Посмотрев на Вовочку, вы также загорелись идеей спортивного 
программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. 
После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то 
информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль 
“файл пустой”, а если он не пустой, то вывести информацию из файла.
### Код
```python
def read_file(filename):
    try:
        with open(filename, 'r') as file:
            content = file.read()
            if len(content) == 0:
                raise Exception("файл пустой")
            else:
                print(content)
    except FileNotFoundError:
        print("Файл не найден")
    except Exception as e:
        print(e)

if __name__ == "__main__":
    read_file("empty_file.txt")
    print("----")
    read_file("data_file.txt")
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Sam2.png)
### Выводы:
- Определен класс "TomatoBush", который представляет куст помидоров.
- В методе "init" класса "TomatoBush" создается динамическое свойство "tomatoes" - это список объектов класса "Tomato", который создается с помощью генератора списков. Создается список томатов в количестве, указанном в параметре "num_tomatoes". Каждый томат имеет порядковый номер от 1 до "num_tomatoes".
- Метод "grow_all" позволяет перевести все томаты куста на следующий этап созревания. Для каждого томата в списке "tomatoes" вызывается метод "grow()", переводящий томат на следующий этап созревания. Затем выводится сообщение о том, что все томаты перешли на следующий этап созревания (при условии, что последний томат перешел на следующий этап).
- Метод "all_are_ripe" проверяет, все ли томаты из списка стали спелыми. Если хотя бы один томат не спелый, метод возвращает False, иначе возвращает True.
- Метод "give_away_all" очищает список томатов после сбора урожая, присваивая ему пустой список.
  
## Самостоятельная работа №3
- Напишите функцию, которая будет складывать 2 и введенное 
пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка 
“Неподходящий тип данных. Ожидалось число.”. Реализовать 
функционал программы необходимо через try/except и подобрать 
правильный тип исключения. Создавать собственное исключение 
нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и 
получившийся вывод в консоль
### Код
```python
def add_two_and_input_number():
    try:
        number = float(input("Введите число: "))
        result = 2 + number
        print(f"Результат сложения 2 и введенного числа: {result}")
    except ValueError:
        print("Неподходящий тип данных. Ожидалось число.")

# Вызов функции для проведения нескольких тестов
add_two_and_input_number(89)
add_two_and_input_number('ovochi')
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Sam3.png)
### Выводы:
- Создан класс "Gardener" для представления садовника.
- В методе "init" класса "Gardener" определены динамические свойства: "name" (передается параметром и является публичным) и "_plant" (принимает объект класса TomatoBush).
- Метод "work" заставляет садовника работать. Для этого вызывается метод "grow_all" у объекта "_plant", увеличивающий созревание всех помидоров на кусте. После этого выводится сообщение о том, что садовник поработал.
- Метод "harvest" проверяет, все ли плоды созрели. Если да, то садовник собирает урожай, вызывая метод "give_away_all" у объекта "_plant", который сбрасывает состояние всех помидоров. Если не все помидоры созрели, то выводится предупреждение.
- В статическом методе "knowledge_base" выводится справка по садоводству, содержащая информацию об искусстве выращивания растений, уходе за ними, обработке почвы и других аспектах садоводства.
  
## Самостоятельная работа №4
- Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые 
использовались ранее в работе нельзя воссоздавать. Результатом 
выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и 
подробные комментарии, которые будут описывать работу вашего 
кода.
### Код
```python
class Tomato:
    # Создаем статическое свойство states, которое будет содержать все стадии созревания помидора
    states = {
        'none': 'отсутствует',
        'blossom': 'цветение',
        'green': 'зелёный',
        'red': 'красный'
    }

    def __init__(self, index):
        # Создаем два динамических свойства: _index (передается параметром) и _state(принимает первое значение из словаря states)
        self._index = index  # _index - это индекс помидора
        self._state = self.states['none']  # _state - это стадия созревания помидора, изначально он отсутствует

    def grow(self):
        # Метод grow() переводит томат на следующую стадию созревания
        if self._state == self.states['none']:
            self._state = self.states['blossom']
        elif self._state == self.states['blossom']:
            self._state = self.states['green']
        elif self._state == self.states['green']:
            self._state = self.states['red']
        #print(f"Помидор номер {self._index} созревает до стадии {self._state}")

    def is_ripe(self):
        # Метод is_ripe() проверяет, что томат созрел
        return self._state == self.states['red']

class TomatoBush:
    def __init__(self, num_tomatoes):
        # Определяем класс TomatoBush с динамическим свойством tomatoes - это список объектов класса Tomato
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]  # создаем список томатов

    def grow_all(self):
        # Метод для перевода всех объектов из списка томатов на следующий этап созревания
        for tomato in self.tomatoes:
            tomato.grow()
        print(f"все томаты перешли на этап {tomato._state}") #ыводится если последний томат перешёл на следующий этап

    def all_are_ripe(self):
        # Метод, который возвращает True, если все томаты из списка стали спелыми
        for tomato in self.tomatoes:
            if not tomato.is_ripe():
                return False
        return True

    def give_away_all(self):
        # Метод, который чистит список томатов после сбора урожая
        self.tomatoes = []


class Gardener:
    def __init__(self, name, plant):
        # Динамические свойства:
        # - name (передается параметром, является публичным)
        # - _plant (принимает объект класса TomatoBush)
        self.name = name  # имя садовника
        self._plant = plant  # растение, за которым ухаживает садовник

    def work(self):
        # Метод work() заставляет садовника работать, что позволяет растению становиться более зрелым
        self._plant.grow_all()  # увеличиваем созревание всех помидоров на кусте
        print(f"садовник {self.name} хорошо поработал.")

    def harvest(self):
        # Метод harvest() проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
        if self._plant.all_are_ripe():
            print(f"{self.name} собирает урожай!")
            self._plant.give_away_all()  # сбрасываем состояние всех помидоров
        else:
            print("Предупреждение: Не все помидоры созрели, нельзя собирать урожай!")

    @staticmethod
    def knowledge_base():
        # Статический метод knowledge_base() выводит в консоль справку по садоводству
        print("Садоводство - это искусство выращивания растений в саду или огороде с целью получения урожая.")
        print("Садовод должен ухаживать за растениями, обрабатывать почву, поливать и удобрять их для успешного выращивания.")


#1)
print('#1')
Gardener.knowledge_base()   #Вызов справки по садоводству

#2)
print('#2')
tomat = TomatoBush(6) #Вызов объектов класса TomatoBush
gardener = Gardener('Михаил', tomat)    #Вызов объектов класса Gardener

#3)
print('#3')
gardener.work() #созревание помидоров, этап цветения

#4)
print('#4')
gardener.harvest() #попытка сбора несозревшего урожая, ,будет выведено сообщение "Предупреждение: Не все помидоры созрели, нельзя собирать урожай!"

#5)
print('#5')
gardener.work() #этап зеленые помидоры
gardener.work() #красные помидоры
gardener.harvest() #сбор урожая


```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Sam4.png)
### Выводы:
- Вызов справки по садоводству с помощью статического метода "knowledge_base"
- Создание объектов tomat и gardener классов TomatoBush и Gardener
- Вызов метода work что заставит садовника поработать
- Вызов метода harvest, попытка сбора несозревшего урожая
- несколько вызовов метода work, до полного созревания томатов и затем с помощью метода harvest осуществляется сбор урожая

## Самостоятельная работа №5
- Создайте собственное исключение, которое будет использоваться в 
двух любых фрагментах кода. Исключения, которые использовались 
ранее в работе нельзя воссоздавать. Результатом выполнения задачи 
будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и 
подробные комментарии, которые будут описывать работу вашего кода.
кода.
### Код
```python
# Создаем собственное исключение
class NegativeNumberError(Exception):
    def __init__(self, value):
        super().__init__(f"Число не может быть отрицательным: {value}")
        self.value = value

# Фрагмент кода, где используется исключение
def calculate_square_root(num):
    if num < 0:
        raise NegativeNumberError(num)
    return num ** 0.5

# Обработка исключения в другом фрагменте кода
try:
    result = calculate_square_root(9)
    print(f"Корень числа: {result}")
    result = calculate_square_root(-4)
    print(f"Корень числа: {result}")
except NegativeNumberError as e:
    print(f"Ошибка: {e}")
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/Sam4.png)
### Выводы:
- Вызов справки по садоводству с помощью статического метода "knowledge_base"
- Создание объектов tomat и gardener классов TomatoBush и Gardener
- Вызов метода work что заставит садовника поработать
- Вызов метода harvest, попытка сбора несозревшего урожая
- несколько вызовов метода work, до полного созревания томатов и затем с помощью метода harvest осуществляется сбор урожая

## Общие выводы по теме
- В данной работе мы использовали наследование, инкапсуляцию, полиморфизм и абстракцию.
- Наследование позволяет создавать новые классы на основе уже существующих, заимствуя их свойства и методы. Это помогает сделать код более модульным и уменьшить его дублирование.
- Инкапсуляция позволяет объединить данные и методы, обрабатывающие их, в одном объекте. Это способствует контролю доступа к данным, предотвращая их нежелательное изменение извне, и обеспечивает защиту от некорректного использования.
- Полиморфизм позволяет одним и тем же именам методов использоваться в разных контекстах, что упрощает работу с различными типами
