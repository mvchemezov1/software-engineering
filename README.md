# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил:
- Чемезов Михаил Владимирович
- АИС-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
- Наверняка вы думаете, что декораторы – это какая-то бесполезная 
вещь, которая вам никогда не пригодится, но тут вдруг на паре по 
математике преподаватель просит всех посчитать число Фибоначчи для 100. Кто-то будет считать вручную (так точно не нужно), кто-то 
посчитает на калькуляторе, а кто-то подумает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, 
потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно тут к вам на помощь приходят 
декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот 
декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программа не будет считать одни и те же значения, а просто “возьмёт их из этого декоратора”). Вам нужно написать 
программу, которая будет считать числа Фибоначчи для 100 и 
запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи.
P.S. при запуске без декоратора можете долго не ждать, для наглядности хватит 10 секунд ожидания.
### Код
- Без декоратора
```python
from functools import lru_cache


#@lru_cache(None) #декоратор динамического программирования
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n - 2)


if __name__ == '__main__':
    print(fibonacci(100))
```

- С декоратором
```python
from functools import lru_cache


#@lru_cache(None) #декоратор динамического программирования
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n - 2)


if __name__ == '__main__':
    print(fibonacci(100))
```

### Результат
- Без декоратора
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab1_1.png)
- С декоратором
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab1_2.png)
### Вывод:
- В начале импортируется функция lru_cache из модуля functools. lru_cache используется для создания мемоизации - сохранения результатов выполнения функции с целью избежания повторных вычислений при одинаковых аргументах.
- Затем определена функция fibonacci, которая вычисляет число Фибоначчи для заданного номера в последовательности.
- Внутри функции реализованы следующие шаги: Если n равно 0, функция возвращает 0. Если n равно 1, функция возвращает 1. В остальных случаях функция вызывает себя рекурсивно для n-1 и n-2, и возвращает сумму их результатов.
- В блоке if __name__ == '__main__': выполняется проверка, является ли данный скрипт основным (или запущен ли он напрямую, а не импортирован в другой скрипт). Если так, то следующая строка кода вызывает функцию fibonacci с аргументом 100 и выводит результат.
- декоратор @lru_cache(None) позволит использовать мемоизацию для ускорения вычислений, так как результаты будут кешироваться и повторно использоваться при вызове функции с теми же аргументами.

## Лабораторная работа №2
- Илья пишет свой сайт и ему необходимо сделать минимальную 
проверку ввода данных пользователя при регистрации. Для этого он 
реализовал функцию, которая выводит данные пользователя на экран и решил, что будет проверять правильность введённых данных при 
помощи декоратора, но в этом ему потребовалась ваша помощь. 
Напишите декоратор для функции, который будет принимать все 
параметры вызываемой функции (имя, возраст) и проверять чтобы 
возраст был больше 0 и меньше 130.
Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента.
### Код
```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func


@check
def personal_info(name, age):
    print(f"Name: {name}, Age: {age}")


if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Петр', 138, 15, 48, 2)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab2.png)
### Вывод:
- Определена функция check, которая принимает в качестве аргумента input_func (функцию) и возвращает функцию output_func. Этот шаблон называется "декоратором".
- Внутри функции check определена вложенная функция output_func, которая принимает переменное число аргументов args. В данном случае, ожидается, что args будет содержать два значения: имя и возраст.
- Внутри output_func извлекаются значения имени и возраста из args и проверяется, находится ли возраст в допустимом диапазоне (от 0 до 130). Если возраст выходит за этот диапазон, то вместо значения возраста присваивается строка 'Недопустимый возраст'.
- Затем функция input_func (передаваемая в качестве аргумента input_func) вызывается с переданными ей значениями имени и возраста после проведения проверки.
- В конце check возвращает output_func. Таким образом, декоратор check готов к использованию.
- Функция personal_info декорирована декоратором @check, что означает, что при вызове personal_info, ее поведение будет изменено в соответствии с функцией check.
- В блоке if __name__ == '__main__': вызываются несколько раз personal_info с разными значениями аргументов для демонстрации работы декоратора.

## Лабораторная работа №3
- Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то 
пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер 
пытается все сломать и вместо нужного типа данных отправляет string.Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт.
Также дополнительно можете обернуть весь код функции в 
try/except/finally для того, чтобы программа вас оповестила о том, что выявлена какая-то ошибка или программа успешно выполнена.
### Код
```python
def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')


if __name__ == '__main__':
    data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab3.png)
### Выводы:
- Определена функция data, которая принимает переменное число аргументов *args. В данном случае, ожидается, что args будет содержать один список.
- Внутри функции data определен блок try-except-finally, который обрабатывает исключения и выполняет определенное действие независимо от возникшей ошибки.
- В блоке try происходит итерация по индексам списка, который передан в качестве аргумента. Каждый элемент списка умножается на 15 и затем делится на 10. Результат выводится на экран.
- Если при попытке выполнения умножения и деления возникает исключение, оно будет обработано блоком except, и сообщение об ошибке будет выведено на экран.
- Если возникло любое другое исключение (кроме тех, что обрабатываются во внутренних блоках try-except), оно будет поймано во внешнем блоке except, и сообщение об ошибке также будет выведено на экран.
- Наконец, в блоке finally выводится сообщение "Вся информация обработана". Этот блок будет выполнен в любом случае, независимо от того, произошли ли исключения или нет.
- В блоке if __name__ == '__main__': вызывается функция data с одним аргументом - списком, содержащим целые числа и строки.
- В конце выполнения программы выводится сообщение "Вся информация обработана", так как этот блок находится в блоке finally.
  
## Лабораторная работа №4
- Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводиться “Успешная регистрация”
### Код
```python
class NegativeValueException(Exception):
    pass


def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')


if __name__ == '__main__':
    name = '12345678910'
    check_name(name)
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab4.png)
### Выводы:
- Определен класс NegativeValueException, который наследуется от встроенного класса Exception. Этот класс может быть использован для создания специальных исключений.
- Затем определена функция check_name, которая принимает один аргумент name.
- Внутри функции происходит проверка длины имени. Если длина имени превышает 10 символов, генерируется исключение NegativeValueException с сообщением "Длина более 10 символов".
- В противном случае, если длина имени не превышает 10 символов, выводится сообщение "Успешная регистрация".
- В блоке if __name__ == '__main__': происходит вызов функции check_name с аргументом name, у которого длина равна 11 символам.
- при вызове функции в блоке if __name__ == '__main__': Переменной name присваивается значение '12345678910'. Затем вызывается функция check_name с этим значением аргумента. Поскольку длина имени name превышает 10 символов, будет сгенерировано исключение NegativeValueException с соответствующим сообщением. Поскольку в коде нет обработчика исключений, программа выведет стандартное сообщение об ошибке и прервет свое выполнение.

## Лабораторная работа №5
- После запуска сайта вы поняли, что вам необходимо добавить логгер, для отслеживания его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для этого создали две функции: __init__() (вызывается при создании класса декоратора в программе) и __call__() (вызывается при вызове 
декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль.
### Код
```python
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного подключения')


@SiteChecker
def site():
    print('Усердная работа сайта')

if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Lab5.png)
### Выводы:
- Создание класса SiteChecker, который принимает один аргумент func в своем конструкторе __init__.
- В методе __init__ происходит инициализация экземпляра класса SiteChecker. При инициализации выводится сообщение > Класс SiteChecker метод __init__ успешный запуск.
- Атрибут self.func устанавливается равным переданной функции.
- Создание специального метода __call__ для класса SiteChecker, который делает экземпляр класса вызываемым.
- В методе __call__ выводится сообщение > Проверка перед запуском с именем функции, и после этого вызывается сохраненная функция self.func().
- Затем выводится сообщение > Проверка безопасного подключения.
- Функция site декорируется экземпляром класса SiteChecker без явного вызова метода __init__. Это возможно благодаря особенностям Python.
- Условие if __name__ == '__main__' проверяет, запущен ли скрипт напрямую (а не импортирован ли он в другой скрипт).
- После этого выводится сообщение >> Сайт запущен, вызывается функция site(), после чего выводится сообщение >> Сайт выключен.
- код создает класс SiteChecker, который используется для проверки и подготовки перед выполнением кода функции site, а затем выполняет эту функцию, выводя дополнительные сообщения до и после ее выполнения.

## Самостоятельная работа №1
- Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. 
Он решил, что для этого ему идеально подойдет декоратор для 
функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор.
Подсказка: необходимо использовать модуль time
Декоратор необходимо использовать для этой функции:
```python
def fibonacci():
  fib1 = fib2 = 1

  for i in range(2, 200):
    fib1, fib2 = fib2, fib1 + fib2
    print(fib2, end=' ')

if __name__ == '__main__': fibonacci()
```
Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы.
Также на этом примере можете посмотреть, что решение задач через рекурсию не всегда является хорошей идеей. Поскольку решение 
Фибоначчи для 100 с использованием рекурсии и без динамического программирования решается более десяти секунд, а решение точно такой же задачи, но через цикл for еще и для 200, занимает меньше 1 секунды.
### Код
```python
import time

def calculate_time(func):
    def wrapper():
        start_time = time.time()
        func()
        end_time = time.time()
        print(f"Время выполнения функции: {end_time - start_time} секунд")
    return wrapper

@calculate_time
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')

if __name__ == '__main__':
    fibonacci()
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Sam1_1.png)
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Sam1_2.png)
### Выводы:
- Импорт модуля time, который предоставляет функции для работы со временем.
- Создание функции calculate_time, которая принимает функцию func в качестве аргумента.
- Внутри функции calculate_time определяется вложенная функция wrapper, которая будет использоваться для измерения времени выполнения функции func.
- Внутри функции wrapper записывается текущее время в start_time, затем выполняется функция func(), после чего записывается текущее время в end_time. Затем выводится сообщение о времени выполнения функции.
- С помощью декоратора @calculate_time при вызове fibonacci() будет вызываться функция wrapper, которая измерит время выполнения fibonacci.
- Определение функции fibonacci, где реализован алгоритм вычисления последовательности Фибоначчи. Создаются переменные fib1 и fib2, инициализирующиеся значением 1. Затем в цикле происходит вычисление следующих чисел последовательности Фибоначчи и их вывод.
- Условие if __name__ == '__main__' проверяет, запущен ли скрипт напрямую (а не импортирован ли он в другой скрипт). И затем вызывается функция fibonacci.
- код использует декоратор calculate_time для измерения времени выполнения функции fibonacci и вывода этого времени.

## Самостоятельная работа №2
- Посмотрев на Вовочку, вы также загорелись идеей спортивного 
программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. 
После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то 
информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль 
“файл пустой”, а если он не пустой, то вывести информацию из файла.
### Код
```python
def read_file(filename):
    try:
        with open(filename, 'r') as file:
            content = file.read()
            if len(content) == 0:
                raise Exception("файл пустой")
            else:
                print(content)
    except FileNotFoundError:
        print("Файл не найден")
    except Exception as e:
        print(e)

if __name__ == "__main__":
    read_file("empty_file.txt")
    print("----")
    read_file("data_file.txt")
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Sam2.png)
### Выводы:
- Определение функции read_file, которая принимает аргумент filename.
- Внутри функции используется блок try-except для обработки исключений.
- В блоке try открывается файл filename в режиме чтения с помощью оператора with open(filename, 'r') as file:.
- После открытия файла читается его содержимое в переменную content с помощью метода file.read().
- Далее происходит проверка наличия содержимого в файле с помощью условного оператора if len(content) == 0:.
- Если содержимое файла пустое, генерируется исключение с помощью оператора raise Exception("файл пустой").
- В случае, если содержимое есть, оно выводится на экран с помощью print(content).
- Если возникает исключение FileNotFoundError, то выводится сообщение "Файл не найден" с помощью print("Файл не найден").
- Дополнительно используется общее исключение Exception для перехвата любых других исключений. Подробная информация об исключении выводится с помощью print(e).
- Условие if __name__ == '__main__' проверяет, запущен ли скрипт напрямую (а не импортирован ли он в другой скрипт). 
- Затем вызываются два вызова функции read_file с разными файлами: "empty_file.txt" и "data_file.txt".
- После выполнения функций выводится разделительная строка "----".

Этот код позволяет открывать файл, читать его содержимое и обрабатывать возможные ошибки, такие как отсутствие файла и пустое содержимое.
  
## Самостоятельная работа №3
- Напишите функцию, которая будет складывать 2 и введенное 
пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка 
“Неподходящий тип данных. Ожидалось число.”. Реализовать 
функционал программы необходимо через try/except и подобрать 
правильный тип исключения. Создавать собственное исключение 
нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и 
получившийся вывод в консоль
### Код
```python
def add_two_and_input_number():
    try:
        number = float(input("Введите число: "))
        result = 2 + number
        print(f"Результат сложения 2 и введенного числа: {result}")
    except ValueError:
        print("Неподходящий тип данных. Ожидалось число.")

# Вызов функции для проведения нескольких тестов
add_two_and_input_number()
add_two_and_input_number()
```
### Результат
- ![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Sam3.png)
### Выводы:
- Определение функции add_two_and_input_number(), которая принимает ввод от пользователя, складывает введенное число с 2 и выводит результат.
- try-блок: В этом блоке происходит попытка выполнить код, который может вызвать исключение.
- number = float(input("Введите число: ")): Здесь происходит запрос у пользователя на ввод числа, которое затем преобразуется в тип float.
- result = 2 + number: Вычисляется сумма 2 и введенного числа.
- print(f"Результат сложения 2 и введенного числа: {result}"): Выводится результат сложения.
- except-блок: В этом блоке обрабатывается исключение типа ValueError, которое возникает, если введенное значение не может быть преобразовано в тип float.
- print("Неподходящий тип данных. Ожидалось число."): Здесь выводится сообщение о том, что введены данные неподходящего типа.
- Далее функция add_two_and_input_number() вызывается дважды для проведения тестов. При вызове функции пользователю предлагается ввести число, и программа обрабатывает результат с учетом возможных ошибок.
  
## Самостоятельная работа №4
- Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые 
использовались ранее в работе нельзя воссоздавать. Результатом 
выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и 
подробные комментарии, которые будут описывать работу вашего 
кода.
### Код
```python
# Создаем класс декоратора
class PrintBeforeAndAfter:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(f"Выполняется функция {self.func.__name__}")
        result = self.func(*args, **kwargs)
        print(f"Функция {self.func.__name__} выполнена")
        return result

# Функция, которая будет использовать декоратор
@PrintBeforeAndAfter
def greet(name):
    print(f"Привет, {name}!")

# Вторая функция, также использующая декоратор
@PrintBeforeAndAfter
def multiply(a, b):
    return a * b

# Вызов функций, украшенных декоратором
greet("Вася")
print(multiply(10, 5))
```
### Результат
![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Sam4.png)
### Выводы:
- Создание класса декоратора, где определены методы __init__ и __call__. Метод __init__ используется для сохранения функции, которая будет использоваться в качестве декорируемой. Метод __call__ вызывается при вызове декорированной функции. В нем выводится сообщение до выполнения функции, затем функция вызывается, и после выполнения выводится соответствующее сообщение.
- При помощи декоратора @PrintBeforeAndAfter функция greet декорируется с использованием класса PrintBeforeAndAfter.
- Аналогично, функция multiply также декорируется с использованием класса PrintBeforeAndAfter.
- При вызове функций greet и multiply будут выводиться сообщения о начале и окончании выполнения функций благодаря использованию декоратора PrintBeforeAndAfter.

## Самостоятельная работа №5
- Создайте собственное исключение, которое будет использоваться в 
двух любых фрагментах кода. Исключения, которые использовались 
ранее в работе нельзя воссоздавать. Результатом выполнения задачи 
будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и 
подробные комментарии, которые будут описывать работу вашего кода.
кода.
### Код
```python
# Создаем собственное исключение
class NegativeNumberError(Exception):
    def __init__(self, value):
        super().__init__(f"Число не может быть отрицательным: {value}")
        self.value = value

# Фрагмент кода, где используется исключение
def calculate_square_root(num):
    if num < 0:
        raise NegativeNumberError(num)
    return num ** 0.5

# Обработка исключения в другом фрагменте кода
try:
    result = calculate_square_root(9)
    print(f"Корень числа: {result}")
    result = calculate_square_root(-4)
    print(f"Корень числа: {result}")
except NegativeNumberError as e:
    print(f"Ошибка: {e}")
```
### Результат
![Результат](https://github.com/mvchemezov1/software-engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/Sam5.png)
### Выводы:
- Создание собственного исключения NegativeNumberError, которое наследуется от встроенного класса Exception. В конструкторе исключения устанавливается сообщение об ошибке, которое включает в себя значение, вызвавшее исключение.
- В Функции calculate_square_root() происходит проверка числа на отрицательность. Если число отрицательное, то возникает исключение NegativeNumberError с передачей в конструктор значения num. В противном случае вычисляется квадратный корень числа и возвращается результат.
- Далее происходит вызов функции calculate_square_root() с аргументами 9 и -4. В первом случае функция выполняется успешно, и результат выводится на экран. Во втором случае возникает исключение NegativeNumberError, которое обрабатывается в блоке except. Сообщение об ошибке выводится на экран с помощью print(f"Ошибка: {e}").
- код создает и использует собственное исключение для обработки ситуации, когда число, для которого вычисляется квадратный корень, является отрицательным.

## Общие выводы по теме
- Декораторы в Python - это мощный инструмент, позволяющий модифицировать поведение функций или методов.
- Декораторы позволяют добавлять функциональность к существующим функциям без изменения их исходного кода.
- Для создания декоратора используется функция, принимающая другую функцию в качестве аргумента и возвращающая новую функцию или обертку.
- Декораторы могут быть использованы для логирования, проверки аутентификации, обработки исключений и других целей.
- Исключения в Python представляют ошибки, возникающие при выполнении программы.
- Python имеет встроенную поддержку обработки исключений при помощи конструкции try-except.
- Конструкция try-except позволяет отлавливать и обрабатывать исключения, предотвращая завершение программы в результате ошибки.
- В блоке except можно указать, какие исключения должны быть перехвачены, и определить соответствующие действия.
- Декораторы и обработка исключений оба являются мощными инструментами, которые позволяют улучшить функциональность и безопасность программы, а также хороши в области управления потоком программы и обработки ошибок.
